# 队长实施指南 - 详细提示词版 v2.0

## 📋 文档说明

本文档为队长（周东吴）提供详细的AI辅助开发实施指南，包含：
- ✅ 每个任务模块的详细AI提示词模板
- ✅ 使用Cursor IDE等工具的具体操作步骤
- ✅ 分步骤的实施流程
- ✅ 可直接复制使用的提示词
- ✅ **v2.0新增**：v6.0-v11.0所有新功能的完整提示词

**文档版本**：v2.0（基于v11.0最终版需求规格说明书）  
**需求文档版本**：v11.0（Final Integrated Version）  
**制定日期**：2026年1月

**使用方式**：在Cursor IDE中按 `Ctrl+K`，然后复制对应的提示词即可开始开发。

---

## 🛠️ 工具准备（第1周开始前）

### 步骤1：安装Cursor IDE

1. 访问 https://cursor.sh/
2. 下载Windows版本并安装
3. 使用GitHub账号登录
4. 打开项目文件夹：`E:\java\MultiModal-PathAI`

### 步骤2：配置MCP服务器（可选，但推荐）

在Cursor设置中添加MCP服务器配置，可以扩展AI能力。

---

## 📅 阶段一：系统架构设计（第1-2周）

### 任务1.1：系统整体架构设计

**在Cursor中操作**：
1. 创建新文件：`docs/系统架构设计.md`
2. 按 `Ctrl+K`，输入以下提示词：

```
我需要设计一个AI赋能职教视频个性化教学系统的完整架构，请帮我生成详细的架构设计文档。

系统需求：
- 前端层：学生端（Vue.js/React）+ 教师端（Vue.js/React）
- 后端服务层：业务逻辑（FastAPI/Spring Boot）、行为采集、路径生成
- AI引擎层：多模态解析（ASR/OCR）、难点识别、资源生成
- 数据存储层：MySQL/PostgreSQL（关系数据）、Redis（缓存）、文件存储（视频/图片）

请生成：
1. 系统分层架构图（Mermaid格式）
2. 各层之间的通信方式（RESTful API、消息队列、WebSocket等）
3. 技术选型建议（具体框架和库）
4. 关键组件的职责划分
5. 数据流向图
6. 部署架构图（开发/测试/生产环境）

要求：
- 架构要支持高并发（1000+并发用户）
- 支持视频文件大文件上传和存储
- AI模型调用要支持异步处理
- 系统要具备良好的扩展性
```

**预期输出**：完整的架构设计文档，包含架构图和详细说明。

---

### 任务1.2：数据库ER图设计

**在Cursor中操作**：
1. 创建新文件：`docs/数据库设计.md`
2. 按 `Ctrl+K`，输入以下提示词：

```
根据以下业务需求，帮我设计完整的数据库ER图和表结构：

核心实体：
1. User（用户）
   - 学生、教师、管理员三种角色
   - 基本信息：id、username、email、password、role、created_at

2. Video（视频）
   - 视频基本信息：id、title、file_path、duration、upload_time、status（待解析/解析中/已完成）
   - 关联：上传者（教师）

3. KnowledgePoint（知识点）
   - 基本信息：id、video_id、name、start_time、end_time、summary、keywords、difficulty
   - 关联：所属视频、前置知识点（依赖关系）

4. WatchEvent（观看事件）
   - 行为数据：id、user_id、knowledge_point_id、event_type（play/pause/seek/replay）、timestamp、duration
   - 用于难点识别

5. Mastery（掌握状态）
   - 学生知识点掌握情况：id、user_id、knowledge_point_id、status（未学/学习中/疑难/已掌握）、updated_at

6. Resource（补偿资源）
   - 资源信息：id、knowledge_point_id、type（知识卡片/练习题/微视频）、content、created_at

7. Exercise（练习题）
   - 题目信息：id、resource_id、question、options、correct_answer、explanation

8. LearningPath（学习路径）
   - 路径信息：id、user_id、knowledge_point_sequence（JSON数组）、created_at、updated_at

关系要求：
- 一个视频有多个知识点（1:N）
- 一个知识点可以有多个补偿资源（1:N）
- 一个知识点可以有多个前置知识点（多对多）
- 一个学生可以有多个观看事件（1:N）
- 一个学生对每个知识点有一个掌握状态（1:1）
- 一个学生有一个学习路径（1:1）

请生成：
1. 完整的ER图（Mermaid格式，包含所有实体和关系）
2. 所有表的SQL建表语句（MySQL语法）
3. 索引策略建议（哪些字段需要索引，为什么）
4. 外键约束设计
5. 数据迁移方案（如何从旧版本升级）

要求：
- 支持知识点依赖关系的存储（可以用邻接表或闭包表）
- 支持观看事件的高频写入（考虑分表策略）
- 支持学习路径的动态更新
- 所有表都要有created_at和updated_at字段
```

**预期输出**：完整的数据库设计文档，包含ER图、SQL语句和索引策略。

---

### 任务1.3：API接口规范设计

**在Cursor中操作**：
1. 创建新文件：`docs/API接口规范.md`
2. 按 `Ctrl+K`，输入以下提示词：

```
我需要设计RESTful API接口规范，请生成完整的OpenAPI 3.0格式文档。

接口分类：

1. 视频管理接口
   - POST /api/videos/upload - 上传视频（支持大文件分片上传）
   - GET /api/videos - 获取视频列表（支持分页、筛选）
   - GET /api/videos/{id} - 获取视频详情
   - GET /api/videos/{id}/knowledge-points - 获取视频的知识点列表
   - DELETE /api/videos/{id} - 删除视频

2. 学习行为接口
   - POST /api/watch-events - 上报观看事件（批量上报）
   - GET /api/users/{id}/watch-events - 获取用户的观看事件
   - GET /api/users/{id}/difficult-points - 获取用户的疑难点列表

3. 补偿资源接口
   - GET /api/knowledge-points/{id}/resources - 获取知识点的补偿资源
   - POST /api/exercises/{id}/submit - 提交练习题答案
   - POST /api/resources/{id}/feedback - 提交资源反馈（已掌握/仍不懂）

4. 学习路径接口
   - GET /api/users/{id}/learning-path - 获取用户的学习路径
   - POST /api/users/{id}/learning-path/regenerate - 重新生成学习路径
   - PUT /api/users/{id}/mastery/{kp_id} - 更新知识点掌握状态

5. 教师端接口
   - GET /api/classes/{id}/statistics - 获取班级学情统计
   - PUT /api/knowledge-points/{id} - 编辑知识点信息
   - GET /api/knowledge-points/{id}/difficulty-stats - 获取知识点困难度统计

请生成：
1. 统一的响应格式（成功/失败）
2. 错误码规范（HTTP状态码 + 业务错误码）
3. 认证授权方案（JWT Token）
4. 完整的OpenAPI 3.0格式文档（YAML格式）
5. 请求/响应示例（JSON格式）
6. 接口调用频率限制说明

要求：
- 所有接口都要有请求参数验证
- 所有接口都要有错误处理说明
- 支持分页的接口要统一分页格式
- 文件上传接口要支持大文件（>100MB）
- 所有接口都要有完整的文档说明
```

**预期输出**：完整的API接口规范文档，包含OpenAPI 3.0格式的接口定义。

---

### 任务1.4：开发规范和代码规范

**在Cursor中操作**：
1. 创建新文件：`docs/开发规范.md`
2. 按 `Ctrl+K`，输入以下提示词：

```
请帮我制定项目开发规范和代码规范文档，包括：

1. 代码风格规范
   - Python代码：遵循PEP 8，使用black格式化，使用mypy类型检查
   - JavaScript/TypeScript：使用ESLint + Prettier
   - 命名规范：变量、函数、类、文件命名规则

2. Git工作流规范
   - 分支命名规范（main/develop/feature/bugfix）
   - 提交信息规范（Conventional Commits）
   - 代码审查流程
   - 合并请求规范

3. 项目目录结构规范
   - 后端项目结构（FastAPI/Spring Boot）
   - 前端项目结构（Vue.js/React）
   - AI算法模块结构
   - 文档目录结构

4. 测试规范
   - 单元测试覆盖率要求（≥80%）
   - 测试文件命名规范
   - 集成测试规范

5. 文档规范
   - 代码注释规范（函数、类、复杂逻辑）
   - API文档更新规范
   - 技术文档编写规范

6. 安全规范
   - 敏感信息处理（API密钥、密码）
   - SQL注入防护
   - XSS防护
   - CSRF防护

请生成完整的规范文档，包含：
- 每个规范的详细说明
- 代码示例（好的例子和坏的例子）
- 工具配置（.editorconfig、.prettierrc等）
- 检查清单（代码提交前检查）
```

**预期输出**：完整的开发规范和代码规范文档。

---

## 📅 阶段二：核心模块开发（第3-8周）

### 模块A：视频多模态解析核心算法（第3-4周）

#### 任务A1：设计知识点切分算法

**在Cursor中操作**：
1. 创建新文件：`algorithm/knowledge_point_segmenter.py`
2. 按 `Ctrl+K`，输入以下提示词：

```
我需要实现一个知识点自动切分算法，请帮我设计算法流程和实现代码。

输入数据：
1. ASR转写文本（带时间戳）
   - 格式：[(start_time, end_time, text), ...]
   - 示例：[(0, 120, "大家好，今天我们来学习函数的概念"), (120, 240, "函数是一种映射关系"), ...]

2. OCR识别的PPT文字（带时间戳）
   - 格式：[(start_time, end_time, text, slide_number), ...]
   - 示例：[(0, 60, "函数定义", 1), (60, 120, "f: A → B", 1), ...]

3. 视频字幕文本（可选，带时间戳）

输出要求：
- 知识点列表，每个知识点包含：
  - name: str - 知识点名称
  - start_time: float - 开始时间（秒）
  - end_time: float - 结束时间（秒）
  - keywords: List[str] - 关键词列表
  - summary: str - 知识点摘要
  - difficulty: str - 难度等级（easy/medium/hard）

算法要求：
1. 基于文本语义相似度进行切分（使用sentence-transformers）
2. 识别话题转换点（语义相似度低于阈值时切分）
3. 每个知识点时长控制在2-10分钟
4. 结合OCR的幻灯片切换点进行切分
5. 使用jieba进行中文分词和关键词提取

技术栈：
- Python 3.9+
- sentence-transformers（语义相似度）
- jieba（中文分词）
- numpy（数值计算）

请帮我：
1. 设计算法流程（伪代码）
2. 实现完整的Python类：KnowledgePointSegmenter
3. 包含以下方法：
   - segment(asr_texts, ocr_texts, subtitles) -> List[KnowledgePoint]
   - calculate_similarity(text1, text2) -> float
   - detect_topic_shift(texts, window_size=3) -> List[int]
   - extract_keywords(text) -> List[str]
   - generate_summary(text) -> str
4. 添加类型注解和文档字符串
5. 添加错误处理和日志记录
6. 提供使用示例

代码要求：
- 遵循PEP 8规范
- 使用类型注解（typing模块）
- 添加详细的文档字符串（Google风格）
- 使用logging记录关键步骤
- 异常处理要完善
```

**预期输出**：完整的知识点切分算法实现代码。

---

#### 任务A2：实现知识点自动标注逻辑

**在Cursor中操作**：
1. 创建新文件：`algorithm/knowledge_point_annotator.py`
2. 按 `Ctrl+K`，输入以下提示词：

```
我需要实现知识点自动标注逻辑，对切分好的知识点进行自动标注。

输入：
- 知识点文本内容
- 知识点起止时间
- 视频的ASR和OCR文本

标注内容：
1. 知识点名称生成
   - 从文本中提取核心概念
   - 使用关键词组合生成名称
   - 名称要简洁（5-15字）

2. 知识点摘要生成
   - 使用文本摘要算法（TextRank或AI模型）
   - 摘要长度控制在50-200字
   - 要包含核心概念和关键信息

3. 关键词提取
   - 提取3-10个关键词
   - 使用TF-IDF或TextRank算法
   - 过滤停用词

4. 难度自动标注
   - 基于文本特征（长度、复杂度、专业术语数量）
   - 使用规则或机器学习模型
   - 输出：easy/medium/hard

5. 知识点类型标注
   - 概念定义、例题讲解、实践操作等
   - 使用文本分类模型

请帮我实现：
1. 类：KnowledgePointAnnotator
2. 方法：
   - annotate(knowledge_point_text, asr_texts, ocr_texts) -> Dict
   - generate_name(text) -> str
   - generate_summary(text) -> str
   - extract_keywords(text, top_k=10) -> List[str]
   - estimate_difficulty(text) -> str
   - classify_type(text) -> str
3. 使用jieba、textrank4zh等库
4. 可以集成AI模型（如调用GPT API生成摘要）
5. 添加配置参数（可以调整算法参数）

代码要求：
- 完整的类型注解
- 详细的文档字符串
- 错误处理和日志
- 提供使用示例和测试用例
```

**预期输出**：知识点自动标注逻辑的实现代码。

---

#### 任务A3：构建知识图谱关系计算

**在Cursor中操作**：
1. 创建新文件：`algorithm/knowledge_graph_builder.py`
2. 按 `Ctrl+K`，输入以下提示词：

```
我需要实现知识图谱关系计算，分析知识点之间的依赖关系。

输入：
- 知识点列表（每个知识点有名称、摘要、关键词）
- 知识点的时序信息（在视频中的顺序）

关系类型：
1. 前置依赖关系（prerequisite）
   - 知识点A是知识点B的前置知识
   - 判断依据：B的文本中提到了A的概念，且A在B之前

2. 相关关系（related）
   - 知识点之间有语义相关性
   - 判断依据：关键词重叠、语义相似度高

3. 包含关系（contains）
   - 知识点A包含知识点B（B是A的子概念）

算法要求：
1. 使用语义相似度计算知识点之间的相关性
2. 使用关键词匹配识别依赖关系
3. 使用时序信息辅助判断（前置知识通常在后面知识之前）
4. 构建有向图（使用networkx）
5. 检测循环依赖并处理

输出：
- 知识图谱（图结构）
- 关系列表：[(source_kp_id, target_kp_id, relation_type, confidence), ...]

请帮我实现：
1. 类：KnowledgeGraphBuilder
2. 方法：
   - build_graph(knowledge_points) -> nx.DiGraph
   - detect_prerequisites(knowledge_points) -> List[Tuple]
   - detect_related(knowledge_points) -> List[Tuple]
   - detect_contains(knowledge_points) -> List[Tuple]
   - detect_cycles(graph) -> List[List]
   - resolve_cycles(graph) -> nx.DiGraph
3. 使用networkx构建图
4. 使用sentence-transformers计算语义相似度
5. 提供可视化方法（使用matplotlib或graphviz）

代码要求：
- 完整的类型注解
- 详细的文档字符串
- 错误处理和日志
- 提供使用示例
- 包含单元测试
```

**预期输出**：知识图谱关系计算的实现代码。

---

#### 任务A4：[v6.0新增] 实现GNN知识依赖图构建

**在Cursor中操作**：
1. 创建新文件：`algorithm/gnn_knowledge_graph.py`
2. 按 `Ctrl+K`，输入以下提示词：

```
我需要实现基于GNN（图神经网络）的知识依赖图构建算法，用于溯源诊断和最短路径计算。

需求（基于v6.0）：
1. 使用GNN构建知识依赖图（节点=知识点，边=依赖关系）
2. 计算知识点之间的最短路径（用于溯源诊断）
3. 支持环路检测（避免死循环）
4. 支持权重计算（依赖强度）

输入：
- 知识点列表（每个知识点有id、名称、摘要）
- 知识点依赖关系列表：[(source_kp_id, target_kp_id, weight), ...]
- 权重来源：依赖强度、时序关系、语义相似度

输出：
- GNN图结构（使用PyTorch Geometric或DGL）
- 最短路径矩阵（用于溯源诊断）
- 环路检测结果

请帮我实现：
1. 类：GNNKnowledgeGraph
2. 方法：
   - build_gnn_graph(knowledge_points, dependencies) -> Graph
   - calculate_shortest_paths(graph) -> Dict[Tuple[int, int], List[int]]
   - detect_cycles(graph) -> List[List[int]]
   - find_root_cause(current_kp_id, difficult_kp_id, graph) -> List[int]
   - visualize_graph(graph) -> None
3. 使用PyTorch Geometric或DGL构建GNN
4. 使用networkx计算最短路径
5. 提供可视化方法

代码要求：
- 完整的类型注解
- 详细的文档字符串
- 错误处理和日志
- 提供使用示例
- 包含GNN模型训练代码（如果需要）
```

**预期输出**：GNN知识依赖图构建的实现代码。

---

#### 任务A5：[v7.0新增] 实现依赖权重修正算法

**在Cursor中操作**：
1. 创建新文件：`algorithm/dependency_weight_corrector.py`
2. 按 `Ctrl+K`，输入以下提示词：

```
我需要实现依赖权重修正算法，基于实际学习数据动态调整知识点依赖关系的权重。

需求（基于v7.0）：
1. 初始权重：基于语义相似度和时序关系
2. 动态修正：基于学生学习数据（掌握率、困难度）
3. 权重更新公式：w_new = w_old × (1 - α) + w_data × α
   - α是学习率（默认0.1）
   - w_data是基于学习数据计算的权重

输入：
- 知识点依赖关系（初始权重）
- 学生学习数据（掌握率、困难度、学习时长）
- 历史权重数据

输出：
- 修正后的依赖权重
- 权重变化报告

请帮我实现：
1. 类：DependencyWeightCorrector
2. 方法：
   - correct_weights(dependencies, learning_data) -> Dict[Tuple[int, int], float]
   - calculate_data_driven_weight(kp_pair, learning_data) -> float
   - update_weights(old_weights, new_weights, alpha=0.1) -> Dict
   - generate_weight_report(weight_changes) -> Dict
3. 支持批量更新
4. 记录权重变化历史
5. 提供权重可视化

代码要求：
- 完整的类型注解
- 详细的文档字符串
- 错误处理和日志
- 提供使用示例
```

**预期输出**：依赖权重修正算法的实现代码。

---

#### 任务A6：[v8.0新增] 实现逻辑环路检测与螺旋路径生成

**在Cursor中操作**：
1. 创建新文件：`algorithm/cycle_detector_spiral_path.py`
2. 按 `Ctrl+K`，输入以下提示词：

```
我需要实现逻辑环路检测算法和螺旋上升路径生成算法。

需求（基于v8.0）：
1. 环路检测：检测知识图谱中的循环依赖（如K3→K5→K7→K3）
2. 螺旋路径生成：对于检测到的环路，生成螺旋上升学习路径
   - 第一轮：K3→K5→K7（基础理解）
   - 第二轮：K3→K5→K7（加深理解）
   - 第三轮：K3→K5→K7（巩固掌握）
3. 跳出机制：如果三轮后仍失败，触发L3干预

输入：
- 知识图谱（有向图）
- 学生的掌握状态
- 学习历史（是否已经走过螺旋路径）

输出：
- 检测到的环路列表
- 螺旋路径序列
- 跳出条件判断

请帮我实现：
1. 类：CycleDetectorSpiralPath
2. 方法：
   - detect_cycles(graph) -> List[List[int]]
   - generate_spiral_path(cycle, mastery_status, attempt_count) -> List[Dict]
   - should_break_spiral(attempt_count, failure_count) -> bool
   - get_spiral_path_status(user_id, cycle_id) -> Dict
3. 使用networkx检测强连通分量
4. 支持多环路处理
5. 记录螺旋路径学习历史

代码要求：
- 完整的类型注解
- 详细的文档字符串
- 错误处理和日志
- 提供使用示例
- 包含螺旋路径可视化
```

**预期输出**：逻辑环路检测与螺旋路径生成的实现代码。

---

#### 任务A7：[v8.0新增] 实现教师预设基准线机制

**在Cursor中操作**：
1. 创建新文件：`algorithm/teacher_baseline_manager.py`
2. 按 `Ctrl+K`，输入以下提示词：

```
我需要实现教师预设基准线机制，允许教师标记核心难点作为基准线。

需求（基于v8.0）：
1. 教师可以标记知识点为"核心难点"（基准线）
2. 基准线知识点在难点识别时权重更高
3. 基准线知识点在补偿推送时优先级更高
4. 支持教师批量设置基准线

输入：
- 知识点列表
- 教师标记的基准线知识点ID列表
- 基准线权重（默认1.5倍）

输出：
- 更新后的知识点权重
- 基准线配置

请帮我实现：
1. 类：TeacherBaselineManager
2. 方法：
   - set_baseline(knowledge_point_ids, teacher_id) -> bool
   - get_baseline_weight(kp_id) -> float
   - apply_baseline_to_difficulty_detection(kp_id, base_score) -> float
   - get_baseline_knowledge_points(video_id) -> List[int]
3. 支持数据库存储基准线配置
4. 支持基准线可视化（在知识图谱中高亮显示）
5. 提供基准线统计报告

代码要求：
- 完整的类型注解
- 详细的文档字符串
- 错误处理和日志
- 提供使用示例
```

**预期输出**：教师预设基准线机制的实现代码。

---

#### 任务A8：[v9.0新增] 实现多模态时间戳对齐协议

**在Cursor中操作**：
1. 创建新文件：`algorithm/multimodal_timestamp_aligner.py`
2. 按 `Ctrl+K`，输入以下提示词：

```
我需要实现多模态时间戳对齐协议，解决ASR、OCR、视频帧之间的时间戳不一致问题。

需求（基于v9.0）：
1. 对齐窗口：±3秒软对齐窗口
2. 对齐算法：基于语义相似度和时间戳距离
3. 语义脱节检测：检测对齐后的语义是否一致
4. 教师校验：语义脱节时通知教师手动校验

输入：
- ASR时间戳列表：[(start, end, text), ...]
- OCR时间戳列表：[(start, end, text, slide_num), ...]
- 视频帧时间戳列表：[(timestamp, frame_data), ...]

输出：
- 对齐后的时间戳
- 对齐质量评分（0-1）
- 语义脱节日志（如果检测到脱节）

请帮我实现：
1. 类：MultimodalTimestampAligner
2. 方法：
   - align_timestamps(asr_data, ocr_data, video_frames) -> Dict
   - calculate_alignment_score(timestamp1, timestamp2, text1, text2) -> float
   - detect_semantic_dissonance(aligned_data) -> List[Dict]
   - request_teacher_verification(dissonance_log) -> bool
3. 使用动态时间规整（DTW）算法对齐时间戳
4. 使用语义相似度验证对齐质量
5. 记录对齐历史和脱节日志

代码要求：
- 完整的类型注解
- 详细的文档字符串
- 错误处理和日志
- 提供使用示例
- 包含对齐质量可视化
```

**预期输出**：多模态时间戳对齐协议的实现代码。

---

#### 任务A9：[v9.0新增] 实现教师一键禁用AI自动生成机制

**在Cursor中操作**：
1. 创建新文件：`algorithm/ai_generation_lock_manager.py`
2. 按 `Ctrl+K`，输入以下提示词：

```
我需要实现教师一键禁用AI自动生成机制，允许教师锁定知识点，进入专家标注模式。

需求（基于v9.0）：
1. 教师可以一键禁用AI自动生成（锁定知识点）
2. 锁定后，系统不再自动生成知识点标注
3. 进入专家标注模式，教师手动标注
4. 支持批量锁定/解锁

输入：
- 视频ID或知识点ID列表
- 教师ID
- 锁定操作（lock/unlock）

输出：
- 锁定状态
- 锁定历史记录

请帮我实现：
1. 类：AIGenerationLockManager
2. 方法：
   - lock_ai_generation(video_id, teacher_id) -> bool
   - unlock_ai_generation(video_id, teacher_id) -> bool
   - is_locked(video_id) -> bool
   - get_lock_history(video_id) -> List[Dict]
3. 支持数据库存储锁定状态
4. 支持锁定状态查询和统计
5. 提供锁定状态可视化

代码要求：
- 完整的类型注解
- 详细的文档字符串
- 错误处理和日志
- 提供使用示例
```

**预期输出**：教师一键禁用AI自动生成机制的实现代码。

---

#### 任务A10：[v10.0新增] 实现写锁租约机制

**在Cursor中操作**：
1. 创建新文件：`algorithm/write_lock_lease_manager.py`
2. 按 `Ctrl+K`，输入以下提示词：

```
我需要实现写锁租约机制，解决教师专家标注时的并发冲突问题。

需求（基于v10.0）：
1. 写锁获取：教师编辑前必须获取写锁
2. 租约时间：30分钟，超时自动释放
3. 续约机制：心跳续约，延长租约时间
4. 原子化发布：编辑完成后原子化发布，交还AI托管
5. 超时回滚：超时未发布，自动回滚到稳定版本

输入：
- 视频ID或知识点ID
- 教师ID
- 操作类型（acquire/renew/release）

输出：
- 锁令牌（lock_token）
- 租约到期时间
- 锁状态

请帮我实现：
1. 类：WriteLockLeaseManager
2. 方法：
   - acquire_lock(video_id, teacher_id) -> Dict[str, Any]
   - renew_lock(lock_token, teacher_id) -> bool
   - release_lock(lock_token, rollback=True) -> bool
   - check_lock_timeout() -> List[Dict]  # 定时任务调用
   - atomic_publish(lock_token, edited_data) -> bool
3. 使用Redis实现分布式锁
4. 支持锁超时自动释放（定时任务）
5. 支持锁状态查询和监控

代码要求：
- 完整的类型注解
- 详细的文档字符串
- 错误处理和日志
- 提供使用示例
- 包含锁状态监控和告警
```

**预期输出**：写锁租约机制的实现代码。

---

#### 任务A11：[v10.0新增] 实现跨课原型匹配冷启动算法

**在Cursor中操作**：
1. 创建新文件：`algorithm/cross_course_prototype_matcher.py`
2. 按 `Ctrl+K`，输入以下提示词：

```
我需要实现跨课原型匹配冷启动算法，对于新课程，自动匹配相似课程的基准线。

需求（基于v10.0）：
1. 相似度计算：计算新课程与已有课程的相似度（基于课程描述、知识点结构）
2. 原型匹配：如果相似度>0.8，自动复用相似课程的基准线
3. 冷启动优化：新课程无需教师手动设置基准线

输入：
- 新课程信息（课程描述、知识点列表）
- 已有课程库（课程描述、知识点结构、基准线配置）

输出：
- 匹配的相似课程ID
- 相似度分数
- 复用的基准线配置

请帮我实现：
1. 类：CrossCoursePrototypeMatcher
2. 方法：
   - calculate_similarity(new_course, existing_course) -> float
   - find_prototype(new_course, course_library) -> Dict
   - apply_prototype_baseline(new_course_id, prototype_course_id) -> bool
   - get_matching_recommendations(new_course) -> List[Dict]
3. 使用语义相似度计算课程相似度
4. 使用知识图谱结构相似度
5. 支持多原型匹配（取平均值）

代码要求：
- 完整的类型注解
- 详细的文档字符串
- 错误处理和日志
- 提供使用示例
- 包含相似度可视化
```

**预期输出**：跨课原型匹配冷启动算法的实现代码。

---

### 模块B：难点识别算法（第5周 + v6.0-v10.0扩展）

#### 任务B1：设计难点判定规则引擎

**在Cursor中操作**：
1. 创建新文件：`algorithm/difficulty_detector.py`
2. 按 `Ctrl+K`，输入以下提示词：

```
我需要实现一个难点识别算法，基于学生的观看行为数据识别疑难点。

输入数据：
1. 学生的观看行为数据
   - replay_count: int - 回放次数
   - pause_count: int - 暂停次数
   - total_watch_time: float - 总观看时长（秒）
   - knowledge_point_duration: float - 知识点视频段时长（秒）
   - seek_count: int - 快进/快退次数
   - last_watch_time: datetime - 最后观看时间

2. 知识点的基本信息
   - difficulty: str - 预设难度（easy/medium/hard）
   - duration: float - 视频段时长

判定规则：
1. 回放次数 >= T1（默认2次）→ 触发疑难点
2. 暂停次数 >= T2（默认3次）→ 触发疑难点
3. 停留时长比 = total_watch_time / knowledge_point_duration >= T3（默认3.0）→ 触发疑难点
4. 快进/快退次数 >= T4（默认5次）→ 触发疑难点

困难度分数计算：
Di = w1 × (replay_count/T1) + w2 × (pause_count/T2) + w3 × (停留时长比/T3) + w4 × (seek_count/T4)

其中：
- w1, w2, w3, w4 是权重（默认：0.3, 0.3, 0.2, 0.2）
- T1, T2, T3, T4 是可配置的阈值

输出：
- is_difficult: bool - 是否为疑难点
- difficulty_score: float - 困难度分数（0-10）
- trigger_reasons: List[str] - 触发原因列表
- confidence: float - 判定置信度（0-1）

请帮我实现：
1. 类：DifficultyDetector
2. 方法：
   - detect(behavior_data, knowledge_point_info) -> Dict
   - calculate_difficulty_score(behavior_data, thresholds, weights) -> float
   - get_trigger_reasons(behavior_data, thresholds) -> List[str]
   - update_thresholds(new_thresholds) -> None
3. 支持配置阈值和权重（使用配置文件或参数）
4. 添加日志记录
5. 提供使用示例和测试用例

代码要求：
- 完整的类型注解
- 详细的文档字符串
- 错误处理
- 支持批量检测（多个学生的行为数据）
```

**预期输出**：难点判定规则引擎的实现代码。

---

#### 任务B2：实现公共难点识别逻辑

**在Cursor中操作**：
1. 创建新文件：`algorithm/public_difficulty_detector.py`
2. 按 `Ctrl+K`，输入以下提示词：

```
我需要实现公共难点识别逻辑，识别多个学生都感到困难的知识点。

输入：
- 多个学生对同一知识点的观看行为数据
- 知识点ID

识别逻辑：
1. 统计每个知识点的困难学生数量
2. 计算困难学生比例 = 困难学生数 / 总学生数
3. 如果困难学生比例 >= 阈值（默认0.3，即30%），则标记为公共难点
4. 计算平均困难度分数

输出：
- is_public_difficulty: bool - 是否为公共难点
- difficulty_ratio: float - 困难学生比例（0-1）
- average_difficulty_score: float - 平均困难度分数
- affected_students: List[int] - 受影响的学生ID列表
- recommendation: str - 教学建议（如：需要重点讲解、需要补充资源等）

请帮我实现：
1. 类：PublicDifficultyDetector
2. 方法：
   - detect_public_difficulty(knowledge_point_id, all_students_behavior) -> Dict
   - calculate_difficulty_ratio(knowledge_point_id, behavior_data) -> float
   - get_recommendation(difficulty_ratio, average_score) -> str
   - batch_detect(video_id) -> List[Dict]  # 批量检测视频的所有知识点
3. 集成DifficultyDetector类（复用难点判定逻辑）
4. 支持数据库查询（从数据库获取行为数据）
5. 提供统计报告生成功能

代码要求：
- 完整的类型注解
- 详细的文档字符串
- 错误处理和日志
- 性能优化（批量处理）
- 提供使用示例
```

**预期输出**：公共难点识别逻辑的实现代码。

---

#### 任务B3：[v6.0新增] 实现信号不协和检测算法

**在Cursor中操作**：
1. 创建新文件：`algorithm/signal_dissonance_detector.py`
2. 按 `Ctrl+K`，输入以下提示词：

```
我需要实现信号不协和检测算法，检测多模态信号之间的不一致性。

需求（基于v6.0）：
1. 多模态信号：视线追踪、微表情、鼠标/键盘行为、视频播放行为
2. 不协和检测：如果多个信号指向不同的认知状态，标记为不协和
3. 交叉验证：使用多模态信号交叉验证难点判定结果
4. 安全熔断：不协和时降低置信度，触发人工确认

输入：
- 多模态信号数据：
  - 视线追踪：gaze_data = [(timestamp, x, y, attention_level), ...]
  - 微表情：emotion_data = [(timestamp, emotion_type, confidence), ...]
  - 鼠标/键盘：interaction_data = [(timestamp, event_type, data), ...]
  - 播放行为：playback_data = [(timestamp, event_type, position), ...]

输出：
- 不协和检测结果：is_dissonant, confidence, conflicting_signals
- 交叉验证结果：validated_difficulty_score, validation_confidence

请帮我实现：
1. 类：SignalDissonanceDetector
2. 方法：
   - detect_dissonance(multimodal_signals) -> Dict
   - cross_validate_difficulty(signals, base_difficulty_score) -> Dict
   - calculate_signal_consistency(signals) -> float
   - trigger_safety_fuse(dissonance_level) -> Dict
3. 使用统计方法检测信号不一致性
4. 使用机器学习模型（可选）提高检测准确率
5. 记录不协和检测历史

代码要求：
- 完整的类型注解
- 详细的文档字符串
- 错误处理和日志
- 提供使用示例
- 包含信号可视化
```

**预期输出**：信号不协和检测算法的实现代码。

---

#### 任务B4：[v6.0新增] 实现溯源式根本原因诊断算法

**在Cursor中操作**：
1. 创建新文件：`algorithm/root_cause_diagnosis.py`
2. 按 `Ctrl+K`，输入以下提示词：

```
我需要实现溯源式根本原因诊断算法，使用GNN回溯找出知识薄弱点的根本原因。

需求（基于v6.0）：
1. GNN回溯：从当前疑难点回溯到前置知识点，找出根本原因
2. 最短路径：使用GNN计算到前置知识点的最短路径
3. 回补路径生成：生成从根本原因到当前疑难点的回补学习路径
4. 认知负荷调节：避免一次性回补太多知识点

输入：
- 当前疑难点ID
- 知识图谱（GNN图结构）
- 学生的掌握状态

输出：
- 根本原因知识点ID列表（按重要性排序）
- 回补路径序列
- 认知负荷评估

请帮我实现：
1. 类：RootCauseDiagnosis
2. 方法：
   - diagnose_root_cause(difficult_kp_id, graph, mastery_status) -> List[int]
   - generate_remedial_path(root_causes, current_kp_id, graph) -> List[Dict]
   - assess_cognitive_load(remedial_path) -> Dict
   - optimize_remedial_path(path, max_load) -> List[Dict]
3. 集成GNNKnowledgeGraph（复用GNN图结构）
4. 使用最短路径算法（Dijkstra或A*）
5. 支持多根本原因处理

代码要求：
- 完整的类型注解
- 详细的文档字符串
- 错误处理和日志
- 提供使用示例
- 包含溯源路径可视化
```

**预期输出**：溯源式根本原因诊断算法的实现代码。

---

#### 任务B5：[v7.0新增] 实现置信度门控机制

**在Cursor中操作**：
1. 创建新文件：`algorithm/confidence_gate.py`
2. 按 `Ctrl+K`，输入以下提示词：

```
我需要实现置信度门控机制，低置信度时不误判，触发人工确认。

需求（基于v7.0）：
1. 置信度计算：基于多模态信号一致性、历史准确率等
2. 门控阈值：置信度<0.7时，不自动判定为疑难点
3. 人工确认：低置信度时，弹出确认窗口，等待学生反馈
4. 盲区处理：如果学生不确认，标记为"待观察"，不强制判定

输入：
- 难点判定结果（is_difficult, difficulty_score）
- 多模态信号数据
- 历史判定准确率

输出：
- 门控后的判定结果（is_difficult, confidence, requires_confirmation）
- 人工确认请求（如果需要）

请帮我实现：
1. 类：ConfidenceGate
2. 方法：
   - calculate_confidence(difficulty_result, signals, history) -> float
   - gate_difficulty_detection(difficulty_result, confidence) -> Dict
   - request_human_confirmation(user_id, kp_id, difficulty_result) -> bool
   - handle_confirmation_response(user_id, kp_id, confirmed) -> Dict
3. 支持配置置信度阈值
4. 记录人工确认历史
5. 提供置信度统计报告

代码要求：
- 完整的类型注解
- 详细的文档字符串
- 错误处理和日志
- 提供使用示例
```

**预期输出**：置信度门控机制的实现代码。

---

#### 任务B6：[v7.0新增] 实现个人认知步频计算算法

**在Cursor中操作**：
1. 创建新文件：`algorithm/cognitive_pace_calculator.py`
2. 按 `Ctrl+K`，输入以下提示词：

```
我需要实现个人认知步频计算算法，动态计算每个学生的学习速度。

需求（基于v7.0）：
1. 认知步频定义：单位时间内掌握的知识点数量
2. 动态阈值：基于个人历史数据，动态调整难点判定阈值
3. 步频加权：在难点判定时，考虑个人认知步频
4. 避免虚假繁荣：快速学习不等于深度理解

输入：
- 学生学习历史（知识点学习时长、掌握时间、练习正确率）
- 知识点难度信息
- 时间窗口（如最近7天）

输出：
- 个人认知步频（知识点/小时）
- 动态阈值调整系数
- 步频加权后的难点判定结果

请帮我实现：
1. 类：CognitivePaceCalculator
2. 方法：
   - calculate_pace(user_id, time_window=7) -> float
   - calculate_dynamic_threshold(user_id, base_threshold) -> float
   - apply_pace_weight(difficulty_score, pace) -> float
   - detect_false_prosperity(pace, mastery_quality) -> bool
3. 使用滑动窗口计算步频
4. 支持步频趋势分析
5. 提供步频可视化

代码要求：
- 完整的类型注解
- 详细的文档字符串
- 错误处理和日志
- 提供使用示例
```

**预期输出**：个人认知步频计算算法的实现代码。

---

#### 任务B7：[v8.0新增] 实现认知步频难度系数加权算法

**在Cursor中操作**：
1. 创建新文件：`algorithm/difficulty_coefficient_weighted.py`
2. 按 `Ctrl+K`，输入以下提示词：

```
我需要实现认知步频难度系数加权算法，避免"虚假繁荣"误报。

需求（基于v8.0）：
1. 难度系数计算：基于全网平均学习时长计算知识点难度系数
2. 步频加权：在计算认知步频时，考虑知识点难度系数
3. 避免误报：快速学习高难知识点时，不误判为"已掌握"
4. 加权公式：adjusted_pace = pace × (1 / difficulty_coefficient)

输入：
- 个人认知步频
- 知识点难度系数（基于全网平均时长）
- 当前学习知识点难度

输出：
- 加权后的认知步频
- 调整后的难点判定阈值

请帮我实现：
1. 类：DifficultyCoefficientWeighted
2. 方法：
   - calculate_difficulty_coefficient(kp_id, global_avg_duration) -> float
   - apply_difficulty_weight(pace, difficulty_coefficient) -> float
   - adjust_difficulty_threshold(base_threshold, weighted_pace) -> float
   - prevent_false_prosperity(difficulty_score, weighted_pace) -> Dict
3. 支持批量计算难度系数
4. 记录难度系数变化历史
5. 提供难度系数统计报告

代码要求：
- 完整的类型注解
- 详细的文档字符串
- 错误处理和日志
- 提供使用示例
```

**预期输出**：认知步频难度系数加权算法的实现代码。

---

#### 任务B8：[v8.0新增] 实现监控信号丢失处理机制

**在Cursor中操作**：
1. 创建新文件：`algorithm/signal_loss_handler.py`
2. 按 `Ctrl+K`，输入以下提示词：

```
我需要实现监控信号丢失处理机制，检测摄像头黑屏/遮挡等情况。

需求（基于v8.0）：
1. 心跳检测：定期检测监控信号是否正常（如摄像头画面）
2. 信号丢失处理：如果检测到信号丢失，强制暂停学习，不计入学习时长
3. 弱网区分：区分网络问题导致的信号丢失和真实遮挡
4. 恢复机制：信号恢复后，自动恢复学习状态

输入：
- 监控信号数据（摄像头画面、视线追踪数据等）
- 网络状态数据
- 学习行为数据

输出：
- 信号丢失检测结果（is_lost, reason, duration）
- 处理动作（pause/resume/ignore）

请帮我实现：
1. 类：SignalLossHandler
2. 方法：
   - detect_signal_loss(signal_data, network_status) -> Dict
   - handle_signal_loss(user_id, video_id, loss_info) -> bool
   - check_heartbeat(signal_source) -> bool
   - resume_after_recovery(user_id, video_id) -> bool
3. 支持多信号源检测（摄像头、视线追踪等）
4. 记录信号丢失历史
5. 提供信号质量监控

代码要求：
- 完整的类型注解
- 详细的文档字符串
- 错误处理和日志
- 提供使用示例
```

**预期输出**：监控信号丢失处理机制的实现代码。

---

#### 任务B9：[v9.0新增] 实现弱网环境降级策略

**在Cursor中操作**：
1. 创建新文件：`algorithm/weak_network_degradation.py`
2. 按 `Ctrl+K`，输入以下提示词：

```
我需要实现弱网环境降级策略，在弱网环境下自动降级监控功能。

需求（基于v9.0）：
1. 网络状态检测：检测网络延迟、带宽、丢包率
2. 降级策略矩阵：根据网络状态，选择不同的降级等级
   - 正常：全量监控
   - 弱网：精简监控（只监控关键行为）
   - 极弱网：仅日志模式（不实时分析）
3. 本地缓存：弱网时，行为数据本地缓存，网络恢复后同步
4. 弱网区分：区分网络问题和真实学习困难

输入：
- 网络状态数据（latency, bandwidth, packet_loss）
- 当前监控模式
- 行为数据

输出：
- 降级等级（full/light/log_only）
- 降级策略配置
- 缓存同步状态

请帮我实现：
1. 类：WeakNetworkDegradation
2. 方法：
   - detect_network_status() -> Dict
   - determine_degradation_level(network_status) -> str
   - apply_degradation_strategy(level) -> Dict
   - cache_behavior_data(user_id, behavior_data) -> bool
   - sync_cached_data(user_id) -> bool
3. 支持IndexedDB本地缓存
4. 支持网络状态监控和告警
5. 提供降级策略可视化

代码要求：
- 完整的类型注解
- 详细的文档字符串
- 错误处理和日志
- 提供使用示例
```

**预期输出**：弱网环境降级策略的实现代码。

---

#### 任务B10：[v10.0新增] 实现硬件画像驱动三级降级算法

**在Cursor中操作**：
1. 创建新文件：`algorithm/hardware_degradation.py`
2. 按 `Ctrl+K`，输入以下提示词：

```
我需要实现硬件画像驱动三级降级算法，根据设备性能自动降级。

需求（基于v10.0）：
1. 硬件画像：周期性采集CPU、内存、GPU、FPS等性能指标
2. 三级降级：
   - 全量模式：CPU<50%, FPS>30
   - 精简模式：50%≤CPU<80%, 20≤FPS<30
   - 仅日志模式：CPU≥80%, FPS<20
3. 权重补偿：降级模式下，自动调整算法权重（0.4→0.8），保证准确率
4. 性能监控：实时监控设备性能，防止页面卡死

输入：
- 硬件性能数据（cpu_usage, memory_usage, gpu_available, fps）
- 当前降级等级
- 算法权重配置

输出：
- 降级等级（full/light/log_only）
- 权重补偿系数
- 性能告警（如果需要）

请帮我实现：
1. 类：HardwareDegradation
2. 方法：
   - collect_hardware_profile() -> Dict
   - determine_degradation_level(hardware_profile) -> str
   - calculate_weight_compensation(level) -> float
   - apply_weight_compensation(algorithm_weights, compensation) -> Dict
   - monitor_performance() -> Dict
3. 支持前端性能API（Performance API）
4. 支持性能数据上报和统计
5. 提供性能监控可视化

代码要求：
- 完整的类型注解
- 详细的文档字符串
- 错误处理和日志
- 提供使用示例
```

**预期输出**：硬件画像驱动三级降级算法的实现代码。

---

### 模块C：学习路径生成算法（第6-7周 + v6.0-v10.0扩展）

#### 任务C1：设计个性化路径生成算法

**在Cursor中操作**：
1. 创建新文件：`algorithm/learning_path_generator.py`
2. 按 `Ctrl+K`，输入以下提示词：

```
我需要实现一个个性化学习路径生成算法，为每个学生生成定制化的学习顺序。

输入：
1. 学生的知识点掌握状态
   - 格式：{knowledge_point_id: status, ...}
   - status: "未学" | "学习中" | "疑难" | "已掌握"

2. 知识点之间的依赖关系
   - 格式：[(source_kp_id, target_kp_id, relation_type), ...]
   - relation_type: "prerequisite" | "related" | "contains"

3. 学生的疑难点列表
   - 格式：[knowledge_point_id, ...]

4. 知识点的难度信息
   - 格式：{knowledge_point_id: difficulty, ...}
   - difficulty: "easy" | "medium" | "hard"

输出：
- 学习路径序列：List[Dict]
  - 每个元素包含：knowledge_point_id, order, reason（推荐原因）
- 下一步学习建议：Dict
  - next_knowledge_point_id, reason, estimated_time

算法逻辑：
1. 跳过已掌握的知识点
2. 优先学习前置知识已掌握的知识点（拓扑排序）
3. 对疑难点优先推送补偿资源，然后再继续学习
4. 考虑难度梯度（先易后难）
5. 动态调整路径顺序（根据学习进度更新）

算法步骤：
1. 构建知识图谱（有向无环图DAG）
2. 使用拓扑排序生成基础路径
3. 根据掌握状态过滤已掌握的知识点
4. 对疑难点进行特殊处理（插入补偿资源学习节点）
5. 优化路径顺序（考虑难度梯度）

请帮我实现：
1. 类：LearningPathGenerator
2. 方法：
   - generate_path(user_id, mastery_status, dependencies, difficult_points) -> List[Dict]
   - topological_sort(graph, mastery_status) -> List[int]
   - filter_mastered(knowledge_points, mastery_status) -> List[int]
   - insert_remedial_resources(path, difficult_points) -> List[Dict]
   - optimize_path_order(path, difficulty_info) -> List[Dict]
   - get_next_suggestion(path, current_position) -> Dict
3. 使用networkx进行图算法
4. 处理循环依赖（检测并报告）
5. 支持路径动态更新（学习进度变化后重新生成）

代码要求：
- 完整的类型注解
- 详细的文档字符串
- 错误处理和日志
- 提供使用示例和测试用例
- 包含算法复杂度分析
```

**预期输出**：个性化学习路径生成算法的实现代码。

---

#### 任务C2：实现动态路径调整逻辑

**在Cursor中操作**：
1. 创建新文件：`algorithm/path_adjuster.py`
2. 按 `Ctrl+K`，输入以下提示词：

```
我需要实现学习路径的动态调整逻辑，根据学生的学习进度实时调整路径。

触发调整的场景：
1. 学生完成了一个知识点学习
2. 学生标记知识点为"已掌握"
3. 学生标记知识点为"疑难"
4. 学生完成了补偿资源学习
5. 学生的学习速度变化（太快或太慢）

调整策略：
1. 如果学生快速掌握了某个知识点，可以跳过相关的基础知识点
2. 如果学生遇到困难，插入更多的基础知识点
3. 如果学生完成了补偿资源，重新评估是否掌握
4. 根据学习速度调整后续知识点的难度梯度

输入：
- 当前学习路径
- 学生的学习事件（完成、掌握、疑难等）
- 当前学习进度

输出：
- 调整后的学习路径
- 调整原因说明
- 建议的下一步行动

请帮我实现：
1. 类：PathAdjuster
2. 方法：
   - adjust_path(current_path, learning_event, progress) -> List[Dict]
   - handle_mastery_event(path, kp_id) -> List[Dict]
   - handle_difficulty_event(path, kp_id) -> List[Dict]
   - handle_completion_event(path, kp_id) -> List[Dict]
   - optimize_for_speed(path, learning_speed) -> List[Dict]
   - get_adjustment_reason(event_type, kp_id) -> str
3. 集成LearningPathGenerator（复用路径生成逻辑）
4. 支持增量调整（只调整受影响的部分，而不是重新生成整个路径）
5. 记录调整历史（用于分析和优化）

代码要求：
- 完整的类型注解
- 详细的文档字符串
- 错误处理和日志
- 提供使用示例
- 考虑性能（增量调整）
```

**预期输出**：动态路径调整逻辑的实现代码。

---

#### 任务C3：实现补偿资源推送策略

**在Cursor中操作**：
1. 创建新文件：`algorithm/remedial_resource_strategy.py`
2. 按 `Ctrl+K`，输入以下提示词：

```
我需要实现补偿资源推送策略，设计智能的资源推送机制。

触发条件：
- 知识点被标记为疑难
- 必须在5分钟内推送

推送策略（状态机）：
1. 首次卡顿（第一次标记为疑难）
   - 推送：知识卡片 + 诊断练习
   - 等待反馈

2. 二次卡顿（练习正确率 < 80%）
   - 推送：知识卡片 + 诊断练习 + 例题讲解
   - 等待反馈

3. 三次卡顿（练习正确率仍 < 80%）
   - 推送：知识卡片 + 诊断练习 + 例题讲解 + 1对1答疑入口
   - 通知教师

反馈机制：
- 练习正确率 >= 80% → 标记"已掌握"，继续学习路径
- 练习正确率 < 80% → 升级干预（进入下一级策略）
- 学生反馈"已掌握" → 标记"已掌握"
- 学生反馈"仍不懂" → 升级干预

避免干预疲劳：
- 同一知识点24小时内最多推送3次
- 如果学生连续标记多个知识点为疑难，优先推送最重要的（依赖关系最多的）
- 推送间隔至少30分钟

请帮我实现：
1. 类：RemedialResourceStrategy
2. 方法：
   - should_push_resource(knowledge_point_id, user_id) -> bool
   - get_push_strategy(difficulty_level, attempt_count) -> Dict
   - push_resource(user_id, knowledge_point_id, strategy) -> bool
   - handle_feedback(user_id, resource_id, feedback_type, exercise_score) -> Dict
   - check_intervention_fatigue(user_id, knowledge_point_id) -> bool
   - get_priority(knowledge_point_ids) -> List[int]
3. 使用状态机管理推送状态
4. 支持配置推送策略（可以调整阈值和策略）
5. 记录推送历史（用于分析和优化）
6. 集成消息队列（异步推送）

代码要求：
- 完整的类型注解
- 详细的文档字符串
- 错误处理和日志
- 提供使用示例
- 包含状态机图（Mermaid格式）
```

**预期输出**：补偿资源推送策略的实现代码。

---

#### 任务C4：[v6.0新增] 实现溯源回补路径生成算法

**在Cursor中操作**：
1. 创建新文件：`algorithm/remedial_path_generator.py`
2. 按 `Ctrl+K`，输入以下提示词：

```
我需要实现溯源回补路径生成算法，为疑难点生成前置知识点的回补学习路径。

需求（基于v6.0）：
1. 溯源诊断：使用GNN回溯找出根本原因知识点
2. 回补路径：生成从根本原因到当前疑难点的学习路径
3. 认知负荷调节：避免一次性回补太多知识点（最多3-5个）
4. 路径优化：优先回补最重要的前置知识点

输入：
- 当前疑难点ID
- 知识图谱（GNN图结构）
- 学生的掌握状态
- 认知负荷限制

输出：
- 回补路径序列（知识点ID列表）
- 路径说明（为什么需要回补这些知识点）
- 认知负荷评估

请帮我实现：
1. 类：RemedialPathGenerator
2. 方法：
   - generate_remedial_path(difficult_kp_id, graph, mastery_status) -> List[Dict]
   - find_root_causes(difficult_kp_id, graph) -> List[int]
   - optimize_path_for_cognitive_load(path, max_load) -> List[Dict]
   - explain_path(path, root_causes) -> str
3. 集成RootCauseDiagnosis（复用溯源诊断逻辑）
4. 使用最短路径算法
5. 支持路径可视化

代码要求：
- 完整的类型注解
- 详细的文档字符串
- 错误处理和日志
- 提供使用示例
```

**预期输出**：溯源回补路径生成算法的实现代码。

---

#### 任务C5：[v7.0新增] 实现进度停滞自动升级（L3自动触发）

**在Cursor中操作**：
1. 创建新文件：`algorithm/progress_stagnation_handler.py`
2. 按 `Ctrl+K`，输入以下提示词：

```
我需要实现进度停滞自动升级机制，检测学习进度停滞并自动触发L3干预。

需求（基于v7.0）：
1. 停滞检测：如果学生在同一知识点停留超过阈值时间（如30分钟），判定为停滞
2. 自动升级：停滞时，自动从L1/L2升级到L3干预
3. L3干预：推送最高级别补偿资源（知识卡片+练习+视频+1对1答疑入口）
4. 通知教师：L3触发时，自动通知教师

输入：
- 学生学习进度数据（当前知识点、停留时长、学习事件）
- 干预历史（当前干预等级、尝试次数）

输出：
- 停滞检测结果（is_stagnant, duration）
- 升级动作（upgrade_to_l3, notify_teacher）
- L3干预配置

请帮我实现：
1. 类：ProgressStagnationHandler
2. 方法：
   - detect_stagnation(user_id, kp_id, time_threshold=30) -> Dict
   - auto_upgrade_to_l3(user_id, kp_id) -> bool
   - trigger_l3_intervention(user_id, kp_id) -> Dict
   - notify_teacher(user_id, kp_id, stagnation_info) -> bool
3. 支持配置停滞阈值
4. 记录停滞和升级历史
5. 提供停滞统计报告

代码要求：
- 完整的类型注解
- 详细的文档字符串
- 错误处理和日志
- 提供使用示例
```

**预期输出**：进度停滞自动升级机制的实现代码。

---

#### 任务C6：[v8.0新增] 实现螺旋上升路径生成算法

**在Cursor中操作**：
1. 创建新文件：`algorithm/spiral_path_generator.py`
2. 按 `Ctrl+K`，输入以下提示词：

```
我需要实现螺旋上升路径生成算法，为检测到的环路生成螺旋学习路径。

需求（基于v8.0）：
1. 环路检测：检测知识图谱中的循环依赖
2. 螺旋路径：对于环路，生成多轮学习路径
   - 第一轮：基础理解（K3→K5→K7）
   - 第二轮：加深理解（K3→K5→K7）
   - 第三轮：巩固掌握（K3→K5→K7）
3. 跳出机制：如果三轮后仍失败，触发L3干预或跳出螺旋

输入：
- 检测到的环路（知识点ID列表）
- 学生的掌握状态
- 学习历史（是否已经走过螺旋路径）

输出：
- 螺旋路径序列（多轮路径）
- 当前轮次和状态
- 跳出条件判断

请帮我实现：
1. 类：SpiralPathGenerator
2. 方法：
   - generate_spiral_path(cycle, mastery_status, attempt_count) -> List[Dict]
   - get_current_round(user_id, cycle_id) -> int
   - should_break_spiral(attempt_count, failure_count) -> bool
   - break_spiral_and_upgrade(user_id, cycle_id) -> Dict
3. 集成CycleDetectorSpiralPath（复用环路检测逻辑）
4. 支持多环路处理
5. 记录螺旋路径学习历史

代码要求：
- 完整的类型注解
- 详细的文档字符串
- 错误处理和日志
- 提供使用示例
```

**预期输出**：螺旋上升路径生成算法的实现代码。

---

#### 任务C7：[v9.0新增] 实现干预抗震荡机制（Hysteresis）

**在Cursor中操作**：
1. 创建新文件：`algorithm/intervention_hysteresis.py`
2. 按 `Ctrl+K`，输入以下提示词：

```
我需要实现干预抗震荡机制，避免短时间内重复触发干预，造成界面震荡。

需求（基于v9.0）：
1. 冷静期机制：干预触发后，5分钟内不再重复触发
2. 滞后效应（Hysteresis）：触发阈值和解除阈值不同，避免频繁切换
3. 状态保持：冷静期内，保持上次干预状态
4. 倒计时显示：前端显示剩余冷静期时间

输入：
- 难点判定结果（is_difficult, difficulty_score）
- 上次干预时间
- 冷静期配置（默认5分钟）

输出：
- 是否触发干预（考虑冷静期）
- 剩余冷静期时间
- 干预状态

请帮我实现：
1. 类：InterventionHysteresis
2. 方法：
   - check_cooldown(user_id, kp_id) -> Dict
   - should_trigger_intervention(difficulty_result, cooldown_status) -> bool
   - apply_hysteresis(trigger_threshold, release_threshold, current_score) -> bool
   - get_remaining_cooldown(user_id, kp_id) -> int
3. 支持配置冷静期时长
4. 记录冷静期历史
5. 提供冷静期统计报告

代码要求：
- 完整的类型注解
- 详细的文档字符串
- 错误处理和日志
- 提供使用示例
```

**预期输出**：干预抗震荡机制的实现代码。

---

#### 任务C8：[v9.0新增] 实现螺旋路径跳出策略

**在Cursor中操作**：
1. 创建新文件：`algorithm/spiral_breakout_strategy.py`
2. 按 `Ctrl+K`，输入以下提示词：

```
我需要实现螺旋路径跳出策略，如果螺旋路径反复失败，自动跳出并升级干预。

需求（基于v9.0）：
1. 失败计数：记录螺旋路径中的失败次数
2. 跳出条件：如果三轮后仍失败，或失败次数≥阈值，触发跳出
3. 跳出动作：跳出螺旋路径，触发L3干预或跳过该知识点
4. 路径调整：跳出后，重新生成学习路径

输入：
- 螺旋路径ID
- 失败次数
- 学习历史

输出：
- 是否跳出（should_breakout）
- 跳出动作（upgrade_to_l3/skip_kp）
- 调整后的路径

请帮我实现：
1. 类：SpiralBreakoutStrategy
2. 方法：
   - check_breakout_condition(spiral_path_id, failure_count) -> bool
   - execute_breakout(user_id, spiral_path_id, action) -> Dict
   - regenerate_path_after_breakout(user_id, skipped_kps) -> List[Dict]
   - record_breakout_history(user_id, spiral_path_id, reason) -> bool
3. 支持配置跳出阈值
4. 记录跳出历史
5. 提供跳出统计报告

代码要求：
- 完整的类型注解
- 详细的文档字符串
- 错误处理和日志
- 提供使用示例
```

**预期输出**：螺旋路径跳出策略的实现代码。

---

#### 任务C9：[v10.0新增] 实现教师激进系数调节算法

**在Cursor中操作**：
1. 创建新文件：`algorithm/teacher_aggression_coefficient.py`
2. 按 `Ctrl+K`，输入以下提示词：

```
我需要实现教师激进系数调节算法，允许教师统一调节干预敏感度。

需求（基于v10.0）：
1. 激进系数范围：0.1-2.0
   - 0.1：非常保守，几乎不触发干预
   - 1.0：默认值，正常触发
   - 2.0：非常激进，容易触发干预
2. 统一调节：教师可以统一调节所有知识点的干预阈值
3. 阈值调整：adjusted_threshold = base_threshold / aggression_coefficient
4. 策略编辑器：提供可视化界面让教师调节系数

输入：
- 基础干预阈值
- 教师设置的激进系数（0.1-2.0）
- 当前难点判定结果

输出：
- 调整后的干预阈值
- 是否触发干预（基于调整后的阈值）

请帮我实现：
1. 类：TeacherAggressionCoefficient
2. 方法：
   - set_aggression_coefficient(teacher_id, coefficient) -> bool
   - adjust_intervention_threshold(base_threshold, coefficient) -> float
   - apply_coefficient_to_detection(difficulty_result, coefficient) -> Dict
   - get_coefficient_config(teacher_id) -> float
3. 支持数据库存储系数配置
4. 支持系数历史记录
5. 提供系数效果统计

代码要求：
- 完整的类型注解
- 详细的文档字符串
- 错误处理和日志
- 提供使用示例
```

**预期输出**：教师激进系数调节算法的实现代码。

---

### 模块D：补偿资源生成（第6-7周 + v6.0-v10.0扩展）

#### 任务D1：设计知识卡片生成模板

**在Cursor中操作**：
1. 创建新文件：`algorithm/knowledge_card_generator.py`
2. 按 `Ctrl+K`，输入以下提示词：

```
我需要实现知识卡片生成功能，为疑难知识点生成补偿学习资源。

知识卡片内容结构：
1. 标题：知识点名称
2. 核心概念：简洁的概念定义（50-100字）
3. 关键公式/定理（如果有）
4. 典型例题：1-2个简单例题
5. 常见误区：学生容易出错的地方
6. 学习建议：如何掌握这个知识点

生成方式：
1. 从原视频中提取相关内容
2. 使用AI模型（GPT/Claude）生成补充内容
3. 使用模板填充（Markdown格式）

输入：
- 知识点信息（名称、摘要、关键词、视频片段）
- 知识点的ASR和OCR文本

输出：
- 知识卡片内容（Markdown格式）
- 包含的公式、图表、代码等

请帮我实现：
1. 类：KnowledgeCardGenerator
2. 方法：
   - generate_card(knowledge_point_info, asr_text, ocr_text) -> str
   - extract_core_concept(text) -> str
   - extract_formulas(text) -> List[str]
   - generate_examples(knowledge_point_info) -> List[Dict]
   - generate_common_mistakes(knowledge_point_info) -> List[str]
   - generate_learning_tips(knowledge_point_info) -> List[str]
   - format_as_markdown(card_content) -> str
3. 集成AI模型API（调用GPT/Claude生成内容）
4. 使用模板引擎（Jinja2）生成卡片
5. 支持缓存（相同知识点不重复生成）

代码要求：
- 完整的类型注解
- 详细的文档字符串
- 错误处理和日志
- AI API调用的错误重试机制
- 提供使用示例
- 包含Markdown模板示例
```

**预期输出**：知识卡片生成功能的实现代码。

---

#### 任务D2：实现练习题自动生成逻辑

**在Cursor中操作**：
1. 创建新文件：`algorithm/exercise_generator.py`
2. 按 `Ctrl+K`，输入以下提示词：

```
我需要实现练习题自动生成功能，为疑难知识点生成诊断练习题。

题目类型：
1. 选择题（4个选项，单选）
2. 填空题
3. 判断题
4. 简答题（可选）

题目要求：
- 难度匹配知识点难度（easy/medium/hard）
- 题目要能诊断学生的理解程度
- 选项要有干扰项（选择题）
- 要有标准答案和详细解析

生成方式：
- 使用AI模型（GPT/Claude）生成题目
- 从原视频中提取相关例题
- 使用模板生成（基于知识点类型）

输入：
- 知识点信息（名称、摘要、难度、类型）
- 知识点的ASR和OCR文本
- 题目数量（默认3-5题）
- 题目难度

输出：
- 练习题列表，每个题目包含：
  - question: str - 题目内容
  - type: str - 题目类型
  - options: List[str] - 选项（选择题）
  - correct_answer: str - 正确答案
  - explanation: str - 详细解析
  - difficulty: str - 题目难度

请帮我实现：
1. 类：ExerciseGenerator
2. 方法：
   - generate_exercises(knowledge_point_info, count=5, difficulty="medium") -> List[Dict]
   - generate_choice_question(knowledge_point_info) -> Dict
   - generate_fill_blank_question(knowledge_point_info) -> Dict
   - generate_true_false_question(knowledge_point_info) -> Dict
   - generate_short_answer_question(knowledge_point_info) -> Dict
   - validate_question(question) -> bool
3. 集成AI模型API（调用GPT/Claude生成题目）
4. 支持题目难度匹配（根据知识点难度生成相应难度的题目）
5. 支持题目质量评估（检查题目是否合理）
6. 支持批量生成

代码要求：
- 完整的类型注解
- 详细的文档字符串
- 错误处理和日志
- AI API调用的错误重试机制
- 提供使用示例
- 包含题目模板示例
```

**预期输出**：练习题自动生成功能的实现代码。

---

#### 任务D3：实现补偿资源推送机制

**在Cursor中操作**：
1. 创建新文件：`algorithm/resource_pusher.py`
2. 按 `Ctrl+K`，输入以下提示词：

```
我需要实现补偿资源推送机制，将生成的资源推送给学生。

推送方式：
1. 实时推送（WebSocket或Server-Sent Events）
2. 消息队列（RabbitMQ/Kafka）
3. 数据库通知（学生登录时查询）

推送内容：
- 知识卡片（Markdown格式）
- 练习题（JSON格式）
- 微视频链接（如果有）

推送时机：
- 知识点被标记为疑难后5分钟内
- 根据推送策略（首次/二次/三次卡顿）

请帮我实现：
1. 类：ResourcePusher
2. 方法：
   - push_resource(user_id, knowledge_point_id, resource_type, resource_content) -> bool
   - push_via_websocket(user_id, resource) -> bool
   - push_via_message_queue(user_id, resource) -> bool
   - push_via_database(user_id, resource) -> bool
   - get_pending_resources(user_id) -> List[Dict]
   - mark_as_read(user_id, resource_id) -> bool
3. 支持多种推送方式（可配置）
4. 支持推送失败重试
5. 记录推送历史
6. 支持批量推送

代码要求：
- 完整的类型注解
- 详细的文档字符串
- 错误处理和日志
- 支持异步推送（使用asyncio或Celery）
- 提供使用示例
```

**预期输出**：补偿资源推送机制的实现代码。

---

#### 任务D4：优化资源质量评估

**在Cursor中操作**：
1. 创建新文件：`algorithm/resource_quality_evaluator.py`
2. 按 `Ctrl+K`，输入以下提示词：

```
我需要实现资源质量评估功能，评估生成的补偿资源的质量。

评估维度：
1. 内容质量
   - 准确性（内容是否正确）
   - 完整性（是否包含必要信息）
   - 清晰度（是否容易理解）

2. 相关性
   - 与知识点的相关度
   - 是否针对学生的疑难点

3. 有效性
   - 学生反馈（已掌握/仍不懂）
   - 练习正确率
   - 学习效果（是否解决了疑难）

评估方法：
- 自动评估（基于内容分析）
- 人工评估（教师审核）
- 学生反馈评估

请帮我实现：
1. 类：ResourceQualityEvaluator
2. 方法：
   - evaluate_content_quality(resource_content) -> Dict
   - evaluate_relevance(resource, knowledge_point) -> float
   - evaluate_effectiveness(resource_id, student_feedback) -> Dict
   - get_quality_score(resource_id) -> float
   - should_regenerate(resource_id, quality_score) -> bool
3. 集成AI模型（评估内容质量）
4. 支持批量评估
5. 生成质量报告

代码要求：
- 完整的类型注解
- 详细的文档字符串
- 错误处理和日志
- 提供使用示例
```

**预期输出**：资源质量评估功能的实现代码。

---

#### 任务D5：[v6.0新增] 实现社会学习模块（知识锦囊）

**在Cursor中操作**：
1. 创建新文件：`algorithm/social_learning_module.py`
2. 按 `Ctrl+K`，输入以下提示词：

```
我需要实现社会学习模块，为疑难知识点生成"知识锦囊"（同伴经验音频）。

需求（基于v6.0）：
1. 知识锦囊：收集已掌握该知识点的学生的经验分享（音频形式）
2. 同伴经验：学生可以录制音频分享学习经验
3. 智能匹配：根据知识点和学习风格匹配最相关的锦囊
4. 质量评估：评估锦囊的质量和相关性

输入：
- 知识点ID
- 学生的学习风格
- 可用的知识锦囊库

输出：
- 匹配的知识锦囊列表（按相关性排序）
- 锦囊内容（音频链接、文字摘要）

请帮我实现：
1. 类：SocialLearningModule
2. 方法：
   - match_knowledge_tips(kp_id, learning_style) -> List[Dict]
   - collect_student_tip(user_id, kp_id, audio_url, transcript) -> bool
   - evaluate_tip_quality(tip_id) -> Dict
   - rank_tips_by_relevance(tips, learning_style) -> List[Dict]
3. 支持音频处理和转录
4. 支持语义相似度匹配
5. 提供锦囊质量统计

代码要求：
- 完整的类型注解
- 详细的文档字符串
- 错误处理和日志
- 提供使用示例
```

**预期输出**：社会学习模块的实现代码。

---

#### 任务D6：[v7.0新增] 实现资源评价细化机制

**在Cursor中操作**：
1. 创建新文件：`algorithm/resource_feedback_refiner.py`
2. 按 `Ctrl+K`，输入以下提示词：

```
我需要实现资源评价细化机制，收集更详细的资源反馈信息。

需求（基于v7.0）：
1. 细化反馈维度：
   - too_verbose（太冗长）
   - too_simple（太简单）
   - content_mismatch（内容不匹配）
   - helpful（有帮助）
2. 多维度反馈：学生可以选择多个反馈维度
3. 反馈分析：基于细化反馈，优化资源生成策略
4. 灰度复核：修正资源前，先灰度发布，收集反馈

输入：
- 资源ID
- 学生反馈（多维度选择）
- 反馈详情（可选文字说明）

输出：
- 反馈分析结果
- 资源优化建议
- 是否需要重新生成

请帮我实现：
1. 类：ResourceFeedbackRefiner
2. 方法：
   - collect_refined_feedback(user_id, resource_id, feedback_dimensions) -> bool
   - analyze_feedback(resource_id) -> Dict
   - generate_optimization_suggestions(feedback_analysis) -> List[str]
   - should_regenerate_resource(resource_id, feedback_score) -> bool
3. 支持反馈维度统计
4. 支持反馈趋势分析
5. 提供反馈报告

代码要求：
- 完整的类型注解
- 详细的文档字符串
- 错误处理和日志
- 提供使用示例
```

**预期输出**：资源评价细化机制的实现代码。

---

#### 任务D7：[v7.0新增] 实现修正资源灰度复核机制

**在Cursor中操作**：
1. 创建新文件：`algorithm/gray_review_mechanism.py`
2. 按 `Ctrl+K`，输入以下提示词：

```
我需要实现修正资源灰度复核机制，修正资源前先灰度发布，收集反馈后再正式发布。

需求（基于v7.0）：
1. 灰度发布：修正资源先发布给部分学生（如10%）
2. 反馈收集：收集灰度用户的反馈
3. 质量评估：基于反馈评估修正资源质量
4. 正式发布：如果质量达标，正式发布；否则继续优化

输入：
- 修正后的资源内容
- 灰度比例（默认10%）
- 质量阈值

输出：
- 灰度发布状态
- 反馈收集结果
- 是否正式发布

请帮我实现：
1. 类：GrayReviewMechanism
2. 方法：
   - gray_release_resource(resource_id, gray_ratio=0.1) -> bool
   - collect_gray_feedback(resource_id) -> Dict
   - evaluate_gray_quality(feedback_data) -> Dict
   - promote_to_production(resource_id, quality_score) -> bool
3. 支持灰度比例配置
4. 支持灰度反馈统计
5. 提供灰度发布报告

代码要求：
- 完整的类型注解
- 详细的文档字符串
- 错误处理和日志
- 提供使用示例
```

**预期输出**：修正资源灰度复核机制的实现代码。

---

#### 任务D8：[v7.0新增] 实现智能剪辑上下文保留协议

**在Cursor中操作**：
1. 创建新文件：`algorithm/smart_clip_context_preserver.py`
2. 按 `Ctrl+K`，输入以下提示词：

```
我需要实现智能剪辑上下文保留协议，剪辑补偿视频时保留前后上下文。

需求（基于v7.0）：
1. 上下文保留：剪辑知识点视频时，保留前5秒+后3秒的上下文
2. 语义连贯性：确保剪辑后的视频语义连贯
3. 智能边界检测：自动检测知识点边界，避免截断关键内容
4. 质量评估：评估剪辑后视频的质量

输入：
- 原视频路径
- 知识点起止时间
- 上下文保留配置（前5s+后3s）

输出：
- 剪辑后的视频路径
- 实际剪辑时间范围（含上下文）
- 剪辑质量评分

请帮我实现：
1. 类：SmartClipContextPreserver
2. 方法：
   - clip_with_context(video_path, start_time, end_time, context_config) -> str
   - detect_semantic_boundary(video_path, target_time, direction) -> float
   - evaluate_clip_quality(clipped_video) -> Dict
   - preserve_context_seamlessly(original, clipped) -> str
3. 使用ffmpeg进行视频处理
4. 使用语义分析检测边界
5. 支持批量剪辑

代码要求：
- 完整的类型注解
- 详细的文档字符串
- 错误处理和日志
- 提供使用示例
```

**预期输出**：智能剪辑上下文保留协议的实现代码。

---

#### 任务D9：[v8.0新增] 实现学习风格自适应过滤器算法

**在Cursor中操作**：
1. 创建新文件：`algorithm/learning_style_filter.py`
2. 按 `Ctrl+K`，输入以下提示词：

```
我需要实现学习风格自适应过滤器算法，根据学生学习风格过滤和匹配补偿资源。

需求（基于v8.0）：
1. 学习风格推断：基于学生反馈数据推断学习风格（视觉型/听觉型/文本型等）
2. 资源标签：为每个补偿资源标注学习风格标签
3. 风格匹配：优先推送匹配学生风格的资源
4. 匹配度提升：风格匹配后，资源匹配度提升≥20%

输入：
- 学生反馈历史（资源类型偏好、学习效果）
- 补偿资源列表（含风格标签）
- 学生的学习风格（如果已推断）

输出：
- 过滤后的资源列表（按风格匹配度排序）
- 学习风格推断结果（如果未推断）
- 匹配度提升报告

请帮我实现：
1. 类：LearningStyleFilter
2. 方法：
   - infer_learning_style(user_id, feedback_history) -> Dict
   - filter_by_style(resources, learning_style) -> List[Dict]
   - calculate_style_match_score(resource, learning_style) -> float
   - rank_resources_by_match(resources, learning_style) -> List[Dict]
3. 使用机器学习模型推断学习风格（可选）
4. 支持风格标签管理
5. 提供风格匹配统计

代码要求：
- 完整的类型注解
- 详细的文档字符串
- 错误处理和日志
- 提供使用示例
```

**预期输出**：学习风格自适应过滤器算法的实现代码。

---

#### 任务D10：[v10.0新增] 实现数据审计引擎

**在Cursor中操作**：
1. 创建新文件：`algorithm/data_audit_engine.py`
2. 按 `Ctrl+K`，输入以下提示词：

```
我需要实现数据审计引擎，检测和过滤异常/恶意反馈。

需求（基于v10.0）：
1. 异常检测：检测异常反馈模式（如未观看就反馈、批量恶意反馈等）
2. 恶意过滤：过滤恶意反馈，不计入资源质量统计
3. 一致性校验：校验反馈与行为的一致性（观看百分比≥80%才计入统计）
4. 难度保护区：高难资源自动下架阈值提高到10（防止恶意反馈误下架）

输入：
- 学生反馈数据
- 学生学习行为数据（观看百分比、完成情况）
- 资源难度信息

输出：
- 审计结果（normal/abnormal/malicious）
- 过滤后的反馈统计
- 审计报告

请帮我实现：
1. 类：DataAuditEngine
2. 方法：
   - audit_feedback(feedback_id, behavior_data) -> Dict
   - check_consistency(feedback, behavior) -> bool
   - detect_anomaly_pattern(feedback_history) -> List[Dict]
   - filter_malicious_feedback(feedback_list) -> List[Dict]
   - apply_difficulty_protection_zone(resource_id, difficulty) -> Dict
3. 使用统计方法检测异常
4. 使用机器学习模型检测恶意（可选）
5. 提供审计报告和可视化

代码要求：
- 完整的类型注解
- 详细的文档字符串
- 错误处理和日志
- 提供使用示例
```

**预期输出**：数据审计引擎的实现代码。

---

#### 任务D11：[v10.0新增] 实现难度保护区机制

**在Cursor中操作**：
1. 创建新文件：`algorithm/difficulty_protection_zone.py`
2. 按 `Ctrl+K`，输入以下提示词：

```
我需要实现难度保护区机制，保护高难资源不被恶意反馈误下架。

需求（基于v10.0）：
1. 难度分级：根据资源难度分级（basic/intermediate/advanced）
2. 保护阈值：高难资源（advanced）的下架阈值提高到10（需要10个负面反馈才下架）
3. 证据要求：高难资源下架需要提供内容不匹配的证据
4. 自动调整：根据资源难度自动调整下架阈值

输入：
- 资源难度等级
- 负面反馈数量
- 反馈证据（内容不匹配等）

输出：
- 是否触发下架（考虑难度保护）
- 保护状态
- 下架建议

请帮我实现：
1. 类：DifficultyProtectionZone
2. 方法：
   - get_protection_threshold(difficulty_level) -> int
   - check_protection_status(resource_id, negative_feedback_count) -> Dict
   - require_evidence_for_advanced(difficulty_level) -> bool
   - evaluate_downgrade_request(resource_id, feedback_evidence) -> Dict
3. 支持配置保护阈值
4. 记录保护历史
5. 提供保护统计报告

代码要求：
- 完整的类型注解
- 详细的文档字符串
- 错误处理和日志
- 提供使用示例
```

**预期输出**：难度保护区机制的实现代码。

---

#### 任务D12：[v10.0新增] 实现反馈-行为一致性校验

**在Cursor中操作**：
1. 创建新文件：`algorithm/feedback_behavior_consistency.py`
2. 按 `Ctrl+K`，输入以下提示词：

```
我需要实现反馈-行为一致性校验，确保反馈的真实性。

需求（基于v10.0）：
1. 一致性校验：校验反馈与学习行为的一致性
   - 如果学生反馈"not_helpful"，但观看百分比<80%，不计入统计
   - 如果学生反馈"helpful"，但未完成练习，降低权重
2. 阈值设置：观看百分比≥80%才计入统计
3. 权重调整：根据一致性调整反馈权重
4. 异常标记：不一致的反馈标记为异常

输入：
- 学生反馈数据
- 学生学习行为数据（观看百分比、完成情况、练习正确率）

输出：
- 一致性校验结果（consistent/inconsistent）
- 调整后的反馈权重
- 异常标记

请帮我实现：
1. 类：FeedbackBehaviorConsistency
2. 方法：
   - check_consistency(feedback, behavior_data) -> Dict
   - calculate_watch_percentage(behavior_data) -> float
   - adjust_feedback_weight(feedback, consistency_score) -> float
   - mark_anomaly(feedback_id, reason) -> bool
3. 支持多维度一致性校验
4. 记录一致性历史
5. 提供一致性统计报告

代码要求：
- 完整的类型注解
- 详细的文档字符串
- 错误处理和日志
- 提供使用示例
```

**预期输出**：反馈-行为一致性校验的实现代码。

---

## 📅 阶段三：技术攻关（贯穿全程）

### 任务3.1：多模态大模型API集成

**在Cursor中操作**：
1. 创建新文件：`ai_integration/multimodal_api_client.py`
2. 按 `Ctrl+K`，输入以下提示词：

```
我需要集成多模态大模型API（GPT-4V、Claude、文心一言），用于视频内容理解和资源生成。

需求：
1. 统一的API接口封装（支持多个模型）
2. 视频内容理解（分析视频帧、理解内容）
3. 知识点摘要生成
4. 补偿资源生成（知识卡片、练习题）

请帮我：
1. 对比各API的优缺点（GPT-4V、Claude、文心一言）
2. 设计统一的接口封装类
3. 实现API调用（支持异步）
4. 处理API限流和错误重试
5. 优化API调用成本（缓存、批量处理）

实现要求：
1. 类：MultimodalAPIClient（抽象基类）
2. 具体实现：GPT4VClient、ClaudeClient、WenxinClient
3. 方法：
   - analyze_video_frame(image_url, prompt) -> Dict
   - generate_summary(text, max_length=200) -> str
   - generate_knowledge_card(knowledge_point_info) -> str
   - generate_exercise(knowledge_point_info) -> Dict
4. 支持配置（API密钥、模型参数）
5. 实现缓存机制（Redis）
6. 实现错误重试（指数退避）
7. 实现批量处理（减少API调用次数）

代码要求：
- 完整的类型注解
- 详细的文档字符串
- 错误处理和日志
- 支持异步调用（asyncio）
- 提供使用示例
- 包含API对比文档
```

**预期输出**：多模态大模型API集成的实现代码。

---

### 任务3.2：视频生成技术方案

**在Cursor中操作**：
1. 创建新文件：`ai_integration/video_generator.py`
2. 按 `Ctrl+K`，输入以下提示词：

```
我需要实现补偿微视频生成功能，为疑难知识点生成讲解视频。

可选方案：
1. Sora-like模型生成（文本/图片→视频）
2. CogVideo生成
3. 图文→视频（Runway、Luma、Kling）
4. 原视频智能剪辑（从原视频中提取相关片段）

请帮我：
1. 对比各方案的可行性、成本、质量
2. 提供MVP版本的最简方案（推荐原视频智能剪辑）
3. 实现视频剪辑功能
4. 设计视频质量评估机制

实现要求：
1. 类：VideoGenerator
2. 方法：
   - generate_from_text(text, images) -> str  # 文本/图片生成视频
   - clip_from_source(video_path, start_time, end_time, knowledge_point_info) -> str  # 智能剪辑
   - evaluate_quality(video_path) -> Dict  # 质量评估
3. 使用ffmpeg进行视频处理
4. 支持视频转码和压缩
5. 支持添加字幕和标注

代码要求：
- 完整的类型注解
- 详细的文档字符串
- 错误处理和日志
- 提供使用示例
- 包含方案对比文档
```

**预期输出**：视频生成技术方案的实现代码。

---

### 任务3.3：性能优化

**在Cursor中操作**：
1. 创建新文件：`optimization/performance_optimizer.py`
2. 按 `Ctrl+K`，输入以下提示词：

```
我的系统存在性能瓶颈，需要优化：

1. 视频解析耗时过长（>24小时）
   - 问题：ASR/OCR处理慢，知识点切分算法慢
   - 优化：异步处理、分布式处理、缓存中间结果

2. 补偿推送响应慢（>5分钟）
   - 问题：资源生成慢，API调用慢
   - 优化：预生成资源、异步推送、缓存

3. API接口响应慢（>500ms）
   - 问题：数据库查询慢、业务逻辑复杂
   - 优化：数据库索引、查询优化、缓存、异步处理

4. 数据库查询慢
   - 问题：缺少索引、查询语句不优化
   - 优化：添加索引、优化SQL、使用缓存

请帮我：
1. 分析性能瓶颈原因
2. 提供优化方案（缓存、异步、索引等）
3. 实现性能监控（记录响应时间、资源使用）
4. 提供代码优化示例

实现要求：
1. 类：PerformanceOptimizer
2. 方法：
   - analyze_bottleneck(function, args) -> Dict
   - optimize_database_queries() -> List[str]
   - add_cache_layer(function) -> Callable
   - async_process(task, args) -> asyncio.Task
   - monitor_performance() -> Dict
3. 使用性能分析工具（cProfile、py-spy）
4. 实现缓存装饰器
5. 实现异步任务队列（Celery）

代码要求：
- 完整的类型注解
- 详细的文档字符串
- 错误处理和日志
- 提供使用示例
- 包含性能优化报告模板
```

**预期输出**：性能优化方案的实现代码。

---

## 📅 阶段四：集成测试与部署（第9-12周）

### 任务4.1：系统集成测试

**在Cursor中操作**：
1. 创建新文件：`tests/integration_test.py`
2. 按 `Ctrl+K`，输入以下提示词：

```
我需要编写系统集成测试，测试整个学习闭环的功能。

测试场景：
1. 视频上传 → 解析 → 知识点切分 → 知识点标注
2. 学生观看视频 → 行为采集 → 难点识别 → 补偿推送
3. 学生完成练习 → 反馈 → 路径调整
4. 教师查看学情统计

请帮我：
1. 设计集成测试用例
2. 实现测试代码（使用pytest）
3. 实现测试数据准备和清理
4. 实现测试报告生成

实现要求：
1. 使用pytest框架
2. 使用fixture准备测试数据
3. 使用mock模拟外部依赖（AI API、数据库）
4. 测试覆盖主要业务流程
5. 生成测试报告（HTML格式）

代码要求：
- 完整的测试用例
- 清晰的测试说明
- 提供测试运行脚本
```

**预期输出**：系统集成测试代码。

---

### 任务4.2：系统部署和运维

**在Cursor中操作**：
1. 创建新文件：`deployment/docker-compose.yml`
2. 按 `Ctrl+K`，输入以下提示词：

```
我需要配置系统部署方案，使用Docker容器化部署。

系统组件：
1. 前端服务（Nginx + Vue.js）
2. 后端服务（FastAPI/Spring Boot）
3. AI服务（Python算法模块）
4. 数据库（MySQL/PostgreSQL）
5. 缓存（Redis）
6. 消息队列（RabbitMQ）

请帮我：
1. 编写Dockerfile（每个服务）
2. 编写docker-compose.yml
3. 配置环境变量
4. 配置Nginx反向代理
5. 配置数据库初始化脚本
6. 编写部署文档

实现要求：
1. 支持开发/测试/生产环境
2. 支持水平扩展（多实例）
3. 配置健康检查
4. 配置日志收集
5. 配置监控（Prometheus + Grafana）

代码要求：
- 完整的Docker配置
- 详细的部署文档
- 提供部署脚本
```

**预期输出**：系统部署配置和文档。

---

## 📝 使用提示词的技巧

### 1. 分步骤提问
不要一次性要求AI实现所有功能，应该：
- 第一步：让AI设计算法流程
- 第二步：让AI实现核心功能
- 第三步：让AI添加测试和文档

### 2. 提供上下文
在使用提示词时，可以引用已有的代码或文档：
```
参考 @knowledge_point_segmenter.py 中的实现方式，帮我实现...
```

### 3. 迭代优化
AI生成的代码可能不完美，需要：
- 先运行测试，发现问题
- 再让AI优化特定问题
- 重复迭代直到满意

### 4. 代码审查
生成代码后，让AI审查：
```
请审查以下代码，找出潜在问题、性能瓶颈、安全漏洞：
[粘贴代码]
```

---

## 🎯 快速开始清单

### 第1周
- [ ] 安装Cursor IDE
- [ ] 使用提示词1.1设计系统架构
- [ ] 使用提示词1.2设计数据库ER图
- [ ] 使用提示词1.3设计API接口规范

### 第2周
- [ ] 使用提示词1.4制定开发规范
- [ ] 创建项目目录结构
- [ ] 初始化Git仓库
- [ ] 配置开发环境

### 第3周
- [ ] 使用提示词A1实现知识点切分算法
- [ ] 使用提示词A2实现知识点标注逻辑
- [ ] 编写单元测试

### 第4周
- [ ] 使用提示词A3实现知识图谱构建
- [ ] 与张亚鹏协作，集成ASR/OCR结果
- [ ] 测试知识点切分功能

### 第5周
- [ ] 使用提示词B1实现难点识别算法
- [ ] 使用提示词B2实现公共难点识别
- [ ] 测试难点识别准确率

### 第6周
- [ ] 使用提示词C1实现学习路径生成
- [ ] 使用提示词C2实现路径动态调整
- [ ] 使用提示词C3实现补偿推送策略

### 第7周
- [ ] 使用提示词D1实现知识卡片生成
- [ ] 使用提示词D2实现练习题生成
- [ ] 使用提示词D3实现资源推送机制

### 第8周
- [ ] 使用提示词D4优化资源质量评估
- [ ] 系统集成和性能优化
- [ ] 编写API文档

### 第8周
- [ ] 使用提示词D4优化资源质量评估
- [ ] 使用提示词A4-A11实现v6.0-v10.0模块A扩展功能
- [ ] 系统集成和性能优化
- [ ] 编写API文档

### 第9周
- [ ] 使用提示词B3-B10实现v6.0-v10.0模块B扩展功能
- [ ] 使用提示词C4-C9实现v6.0-v10.0模块C扩展功能
- [ ] 使用提示词D5-D12实现v6.0-v10.0模块D扩展功能
- [ ] 测试v6.0-v10.0新功能

### 第10周
- [ ] 完成v9.0-v10.0边界异常逻辑补齐
- [ ] 完成系统健壮性增强（写锁、降级、审计等）
- [ ] 集成测试v6.0-v10.0所有新功能
- [ ] 性能优化和bug修复

### 第11-14周
- [ ] 使用提示词4.1编写集成测试（含v6.0-v10.0）
- [ ] 使用提示词4.2配置系统部署
- [ ] 完整功能测试和验收
- [ ] 准备项目演示

---

## 📚 参考资源

- **Cursor IDE文档**：https://docs.cursor.sh/
- **MCP协议文档**：https://modelcontextprotocol.io/
- **Python最佳实践**：PEP 8、Google Python Style Guide
- **FastAPI文档**：https://fastapi.tiangolo.com/
- **NetworkX文档**：https://networkx.org/

---

---

## 📌 v2.0版本更新说明

### 新增功能提示词（v6.0-v10.0）

**模块A扩展（v6.0-v10.0）**：
- A4: GNN知识依赖图构建
- A5: 依赖权重修正算法
- A6: 逻辑环路检测与螺旋路径生成
- A7: 教师预设基准线机制
- A8: 多模态时间戳对齐协议
- A9: 教师一键禁用AI自动生成机制
- A10: 写锁租约机制
- A11: 跨课原型匹配冷启动算法

**模块B扩展（v6.0-v10.0）**：
- B3: 信号不协和检测算法
- B4: 溯源式根本原因诊断算法
- B5: 置信度门控机制
- B6: 个人认知步频计算算法
- B7: 认知步频难度系数加权算法
- B8: 监控信号丢失处理机制
- B9: 弱网环境降级策略
- B10: 硬件画像驱动三级降级算法

**模块C扩展（v6.0-v10.0）**：
- C4: 溯源回补路径生成算法
- C5: 进度停滞自动升级（L3自动触发）
- C6: 螺旋上升路径生成算法
- C7: 干预抗震荡机制（Hysteresis）
- C8: 螺旋路径跳出策略
- C9: 教师激进系数调节算法

**模块D扩展（v6.0-v10.0）**：
- D5: 社会学习模块（知识锦囊）
- D6: 资源评价细化机制
- D7: 修正资源灰度复核机制
- D8: 智能剪辑上下文保留协议
- D9: 学习风格自适应过滤器算法
- D10: 数据审计引擎
- D11: 难度保护区机制
- D12: 反馈-行为一致性校验

### 使用建议

1. **按版本顺序开发**：建议先完成v4.0基础功能，再逐步添加v6.0-v10.0扩展功能
2. **模块化开发**：每个新功能都是独立的模块，可以并行开发
3. **测试驱动**：每实现一个新功能，立即编写测试用例
4. **文档同步**：实现新功能时，同步更新API文档和技术文档

---

**祝你开发顺利！** 🚀

如有问题，随时在Cursor中使用 `Ctrl+K` 提问AI助手。

**文档版本**：v2.0  
**最后更新**：2026年1月  
**需求文档版本**：v11.0（Final Integrated Version）
